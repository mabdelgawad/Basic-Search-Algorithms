/*
 * bellman_ford.hpp file: Header file represents
 * the Bellman-Ford Algorithm Class ***
 * Project Start Date  : June 30, 2020
 * Author    : Mahmoud Abdelgawad
 *
 */

#pragma once

#include <deque>
#include <unordered_set>

#include "graph.hpp"
#include "hashfunction.hpp"


namespace WeightedGraphSearch {

//! define a pair of (f-value , Node) as
//! queue element
typedef std::pair<int, Node> PQ_element;

//! infinite number as 9999999
#define INFINITE_NUM 9999999

class BellmanFord
{
public:
    //! Constructor
    BellmanFord(Graph graph_, int h_value_ = 0):
        graph(graph_), h_value(h_value_) {}

    //! Destructor
    virtual ~BellmanFord(){}

    //! Bellman-Ford process to find a path
    //! from start node to target node
    std::deque<Node> findPath(Node&, Node&);

private:

    //! Member functions -----------------------------------

    //! private member functions help findPath to find
    //! a path from start to goal node, as:

    //! clean frontier, close list, parents, and path
    void clean();

    //! close list node duplication detection
    bool frontierContainNode(Node&) const;

    //! closed list node duplication detection
    bool closedListContainNode(Node&) const;

    //! Updating frontier, close list, and parents
    void improve(PQ_element&, PQ_element&, int);

    //! build a path using backtracking
    void Path(Node&);

    //! remove a node from closed list
    void removeNodeFromcloseList(Node& node);


    //! Data member defination ----------------------------

    //! Directed Graph
    Graph graph;

    //! frontiers is a queue (FIFO)
    std::deque<PQ_element> frontier;

    //! closed_list (a set of visited nodes)
    std::unordered_set<Node, myNodeHashFunction> closed_list;

    //! parent is set of predecessor & successor used
    //! for backtracking a path
    std::vector<Edge> parents;

    //! path generated by Bellman-Ford's process
    std::deque<Node> path;

    //! heuristic value
    int h_value = 0;
};

} /* end of the name space */
